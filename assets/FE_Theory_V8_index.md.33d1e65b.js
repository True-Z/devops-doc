import{_ as o,o as e,c as t,Q as a}from"./chunks/framework.32dba02b.js";const r="/devops-doc/assets/V8是什么.485ff7d3.webp",i="/devops-doc/assets/V8执行流程.ec483eef.webp",n="/devops-doc/assets/解释.d0b7aa4c.webp",s="/devops-doc/assets/编译.61c4a031.webp",c="/devops-doc/assets/Parse.5b883701.png",l="/devops-doc/assets/基于寄存器的解释器架构.c792cb4e.png",p="/devops-doc/assets/ignition-turbofan-pipeline.3427e748.png",V=JSON.parse('{"title":"V8 简介","description":"","frontmatter":{},"headers":[],"relativePath":"FE_Theory/V8/index.md","filePath":"FE_Theory/V8/index.md","lastUpdated":1708148918000}'),d={name:"FE_Theory/V8/index.md"},h=a('<h1 id="v8-简介" tabindex="-1">V8 简介 <a class="header-anchor" href="#v8-简介" aria-label="Permalink to &quot;V8 简介&quot;">​</a></h1><blockquote><p>V8 是 Google 的开源高性能 JavaScript 和 WebAssembly 引擎，用 C++编写。它用于 Chrome 和 Node.js 等。它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本、macOS 10.12+以及使用 x64、IA-32、ARM 或 MIPS 处理器的 Linux 系统上运行。V8 可以独立运行，也可以嵌入到任何 C++应用程序中。</p></blockquote><p><img src="'+r+'" alt="img"></p><h2 id="执行流程" tabindex="-1">执行流程 <a class="header-anchor" href="#执行流程" aria-label="Permalink to &quot;执行流程&quot;">​</a></h2><p><img src="'+i+'" alt="img"></p><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><h3 id="解释执行" tabindex="-1">解释执行 <a class="header-anchor" href="#解释执行" aria-label="Permalink to &quot;解释执行&quot;">​</a></h3><blockquote><p>解释（Interpret）的过程是把源程序代码一行一行的读懂，然后一行一行的执行，发生在运行时，产物是<strong>运行结果</strong>。</p><p>解释器（interpreter），是一种计算机程序，能够把解释型语言解释执行。其实就是执行解释的过程。</p></blockquote><p><img src="'+n+'" alt="img"></p><h3 id="编译执行" tabindex="-1">编译执行 <a class="header-anchor" href="#编译执行" aria-label="Permalink to &quot;编译执行&quot;">​</a></h3><blockquote><p>编译（Compile）的过程是把整个源程序代码翻译成另外一种代码，翻译后的代码等待被执行或者被优化等等，发生在运行之前，产物是<strong>另一份代码</strong>。</p><p>编译器（Compiler）是一种计算机程序，它会将某种编程语言编写的源代码（原始语言）转换成另一种编程语言（目标语言），其实就是完成上文中所说的编译的过程。主要目的是将便于人编写、阅读维护的高级计算机语言所编写的源代码程序，翻译为计算机能运行的机器语言程序。</p></blockquote><p><img src="'+s+'" alt="img"></p><h3 id="字节码" tabindex="-1">字节码 <a class="header-anchor" href="#字节码" aria-label="Permalink to &quot;字节码&quot;">​</a></h3><blockquote><p><strong>早期的 V8</strong> 为了提升代码的<strong>执行速度</strong>，直接将 JavaScript 源代码编译成了<strong>没有优化的二进制机器代码</strong>，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为<strong>热点代码</strong>，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。</p></blockquote><p>随着移动设备的普及，V8 团队逐渐发现将 JavaScript 源码直接编译成二进制代码存在两个致命的问题：</p><ol><li><strong>时间问题</strong>：编译时间过久，影响代码启动速度；</li><li><strong>空间问题</strong>：缓存编译后的二进制代码占用更多的内存。</li></ol><p>这两个问题无疑会阻碍 V8 在移动设备上的普及，于是 V8 团队大规模重构代码，引入了中间的字节码。字节码的优势有如下三点：</p><ul><li><strong>解决启动问题</strong>：生成字节码的时间很短；</li><li><strong>解决空间问题</strong>：字节码虽然占用的空间比原始的 JavaScript 多，但是相较于机器代码，字节码还是小了太多，缓存字节码会大大降低内存的使用。</li><li><strong>代码架构清晰</strong>：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。</li></ul><h3 id="机器码-bytecode" tabindex="-1">机器码（Bytecode） <a class="header-anchor" href="#机器码-bytecode" aria-label="Permalink to &quot;机器码（Bytecode）&quot;">​</a></h3><blockquote><p><strong>某种程度上就是汇编语言，只是它没有对应特定的 CPU，或者说它对应的是虚拟的 CPU</strong>。这样的话，生成 Bytecode 时简单很多，无需为不同的 CPU 生产不同的代码。要知道，V8 支持 9 种不同的 CPU，引入一个中间层 Bytecode，可以简化 V8 的编译流程，提高可扩展性。</p><p>如果我们在不同硬件上去生成 Bytecode，会发现生成代码的指令是一样的。</p></blockquote><h2 id="引擎结构" tabindex="-1">引擎结构 <a class="header-anchor" href="#引擎结构" aria-label="Permalink to &quot;引擎结构&quot;">​</a></h2><h3 id="parse" tabindex="-1">Parse <a class="header-anchor" href="#parse" aria-label="Permalink to &quot;Parse&quot;">​</a></h3><blockquote><p>将 JavaScript 源码转换为 Abstract Syntax Tree (AST)</p><p>确切的说，在“Parser”将 JavaScript 源码转换为 AST 前，还有一个叫”Scanner“的过程，具体流程如下：</p></blockquote><p><img src="'+c+'" alt="img"></p><h3 id="ignition" tabindex="-1">Ignition <a class="header-anchor" href="#ignition" aria-label="Permalink to &quot;Ignition&quot;">​</a></h3><blockquote><p>解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型。</p><p><strong>通常有两种类型的解释器，基于栈 (Stack-based)和基于寄存器 (Register-based)</strong>，</p><p>基于栈的解释器使用栈来保存函数参数、中间运算结果、变量等；</p><p>基于寄存器的虚拟机则支持寄存器的指令操作，使用寄存器来保存参数、中间计算结果。</p><p>通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其<strong>区别体现在它们提供的指令集体系</strong>。<strong>大多数解释器都是基于栈的</strong>，比如 Java 虚拟机，.Net 虚拟机，还有早期的 V8 虚拟机。基于堆栈的虚拟机在处理函数调用、解决递归问题和切换上下文时简单明快。而<strong>现在的 V8 虚拟机则采用了基于寄存器的设计</strong>，它将一些中间数据保存到寄存器中。</p></blockquote><p><img src="'+l+'" alt="基于寄存器的解释器架构"></p><h3 id="turbofan" tabindex="-1">TurboFan <a class="header-anchor" href="#turbofan" aria-label="Permalink to &quot;TurboFan&quot;">​</a></h3><blockquote><p>编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化的汇编代码。</p></blockquote><h3 id="orinoco" tabindex="-1">Orinoco <a class="header-anchor" href="#orinoco" aria-label="Permalink to &quot;Orinoco&quot;">​</a></h3><blockquote><p>垃圾回收模块，负责将程序不再需要的内存空间回收。</p></blockquote><p><img src="'+p+'" alt="img"></p><p>简单地说，<strong>Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)</strong>。</p><ul><li>如果函数没有被调用，则 V8 不会去编译它。</li><li>如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。</li><li>如果函数被调用多次，则它有可能会被识别为<strong>热点函数</strong>，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。</li></ul><p>图片中的红色虚线是逆向的，也就是说 Optimized Machine Code 会被还原为 Bytecode，这个过程叫做 <strong>Deoptimization</strong>。这是因为 Ignition 收集的信息可能是错误的，比如 add 函数的参数之前是整数，后来又变成了字符串。生成的 Optimized Machine Code 已经假定 add 函数的参数是整数，那当然是错误的，于是需要进行 Deoptimization。</p><p>在运行 C、C++以及 Java 等程序之前，需要进行编译，不能直接执行源码；但对于 JavaScript 来说，我们可以直接执行源码(比如：node test.js)，它是在运行的时候先编译再执行，这种方式被称为<strong>即时编译(Just-in-time compilation)</strong>，<strong>简称为 JIT</strong>。因此，V8 也属于 <strong>JIT 编译器</strong>。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://v8.dev/" target="_blank" rel="noreferrer">V8</a></li></ul>',38),g=[h];function b(u,m,_,q,k,f){return e(),t("div",null,g)}const S=o(d,[["render",b]]);export{V as __pageData,S as default};
