import{_ as t,o as e,c as r,Q as a}from"./chunks/framework.32dba02b.js";const o="/devops-doc/assets/Git工作区域.7f6dadd0.png",i="/devops-doc/assets/Git文件状态.62a7ed0d.png",s="/devops-doc/assets/其他系统在每个版本中记录着各个文件的具体差异.dba45a45.png",l="/devops-doc/assets/Git保存每次更新时的文件快照.613406db.png",x=JSON.parse('{"title":"Git 简介","description":"","frontmatter":{},"headers":[],"relativePath":"Tools_Git/index.md","filePath":"Tools_Git/index.md","lastUpdated":1708148918000}'),n={name:"Tools_Git/index.md"},d=a('<h1 id="git-简介" tabindex="-1">Git 简介 <a class="header-anchor" href="#git-简介" aria-label="Permalink to &quot;Git 简介&quot;">​</a></h1><blockquote><p><a href="https://zh.wikipedia.org/wiki/Git" target="_blank" rel="noreferrer">Git</a> 是一个免费开源的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。其易于学习，占用空间小，性能快如闪电。超越了 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具，具有廉价的本地分支、方便的暂存区和多个工作流等功能。</p><ul><li>下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noreferrer">https://git-scm.com/downloads</a></li></ul></blockquote><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><h3 id="工作区域" tabindex="-1">工作区域 <a class="header-anchor" href="#工作区域" aria-label="Permalink to &quot;工作区域&quot;">​</a></h3><p><img src="'+o+'" alt="Git工作区域"></p><ul><li><p><strong>Workspace</strong> 工作区：存放项目代码的目录。</p></li><li><p><strong>Index/Stage</strong> 暂存区：保存下次提交的文件列表信息，本质上是一个叫 index 的文件，一般在 Git 仓库目录中，通常多数说法还是叫暂存区域。</p></li><li><p><strong>Repository</strong> 仓库区（或版本库）：存放数据的位置，存放所有提交到仓库区的版本数据。其中 HEAD 指向最新放入仓库的版本。</p></li><li><p><strong>Remote</strong> 远程仓库：托管代码的服务器。</p></li></ul><h3 id="文件状态" tabindex="-1">文件状态 <a class="header-anchor" href="#文件状态" aria-label="Permalink to &quot;文件状态&quot;">​</a></h3><p><img src="'+i+'" alt="Git文件状态"></p><ul><li><p><strong>Untracked</strong> 未跟踪：文件不参与版本控制。</p></li><li><p><strong>Unmodify</strong> 未修改：文件为最新状态。</p></li><li><p><strong>Modified</strong> 已修改：文件已修改。</p></li><li><p><strong>Staged</strong> 暂存状态：文件修改已暂时记录。</p></li></ul><h3 id="版本控制系统-version-control-system-vcs" tabindex="-1">版本控制系统（Version Control System，VCS） <a class="header-anchor" href="#版本控制系统-version-control-system-vcs" aria-label="Permalink to &quot;版本控制系统（Version Control System，VCS）&quot;">​</a></h3><p>帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。</p><table><thead><tr><th style="text-align:center;">代</th><th style="text-align:center;">网络</th><th style="text-align:center;">操作</th><th style="text-align:center;">并发性</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>第一代（本地版本控制系统）</strong></td><td style="text-align:center;">无</td><td style="text-align:center;">仅一个文件</td><td style="text-align:center;">锁定的</td></tr><tr><td style="text-align:center;"><strong>第二代（集中化版本控制系统）</strong></td><td style="text-align:center;">集中式</td><td style="text-align:center;">多文件</td><td style="text-align:center;">提交之前合并</td></tr><tr><td style="text-align:center;"><strong>第三代（分布式版本控制系统）</strong></td><td style="text-align:center;">分布式</td><td style="text-align:center;">变更的集合</td><td style="text-align:center;">合并之前提交</td></tr></tbody></table><h4 id="本地版本控制系统-local-version-control-system-lvcs" tabindex="-1">本地版本控制系统（Local Version Control System，LVCS） <a class="header-anchor" href="#本地版本控制系统-local-version-control-system-lvcs" aria-label="Permalink to &quot;本地版本控制系统（Local Version Control System，LVCS）&quot;">​</a></h4><p>通过加锁将并发执行转换成顺序执行。一次只能有一个人处理文件。</p><blockquote><p><strong>悲观锁</strong></p><ul><li><p>每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。</p></li><li><p>由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。</p></li></ul></blockquote><h4 id="集中化版本控制系统-centralized-version-control-systems-cvcs" tabindex="-1">集中化版本控制系统（Centralized Version Control Systems，CVCS） <a class="header-anchor" href="#集中化版本控制系统-centralized-version-control-systems-cvcs" aria-label="Permalink to &quot;集中化版本控制系统（Centralized Version Control Systems，CVCS）&quot;">​</a></h4><p>对同步修改更加宽容，但有一个明显的限制，用户必须在允许提交之前将当前修订合并到他们的工作中。</p><blockquote><p><strong>乐观锁</strong></p><ul><li><p>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。</p></li><li><p>如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</p></li></ul></blockquote><h4 id="分布式版本控制系统-distributed-version-control-systems-dvcs" tabindex="-1">分布式版本控制系统（Distributed Version Control Systems，DVCS） <a class="header-anchor" href="#分布式版本控制系统-distributed-version-control-systems-dvcs" aria-label="Permalink to &quot;分布式版本控制系统（Distributed Version Control Systems，DVCS）&quot;">​</a></h4><p>允许合并和提交分开。在每个使用者电脑上就有一个完整的数据仓库，没有网络依然可以使用。</p><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><h3 id="直接记录快照-而非差异比较" tabindex="-1">直接记录快照，而非差异比较 <a class="header-anchor" href="#直接记录快照-而非差异比较" aria-label="Permalink to &quot;直接记录快照，而非差异比较&quot;">​</a></h3><p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。如图所示：</p><p><img src="'+s+'" alt="其他系统在每个版本中记录着各个文件的具体差异"></p><p>Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。如图所示：</p><p><img src="'+l+'" alt="Git保存每次更新时的文件快照"></p><h3 id="近乎所有操作都是本地执行" tabindex="-1">近乎所有操作都是本地执行 <a class="header-anchor" href="#近乎所有操作都是本地执行" aria-label="Permalink to &quot;近乎所有操作都是本地执行&quot;">​</a></h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。</p><h3 id="时刻保持数据完整性" tabindex="-1">时刻保持数据完整性 <a class="header-anchor" href="#时刻保持数据完整性" aria-label="Permalink to &quot;时刻保持数据完整性&quot;">​</a></h3><p>在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p><h3 id="多数操作仅添加数据" tabindex="-1">多数操作仅添加数据 <a class="header-anchor" href="#多数操作仅添加数据" aria-label="Permalink to &quot;多数操作仅添加数据&quot;">​</a></h3><p>常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。</p><h2 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h2><h3 id="tortoisegit" tabindex="-1">TortoiseGit <a class="header-anchor" href="#tortoisegit" aria-label="Permalink to &quot;TortoiseGit&quot;">​</a></h3><blockquote><p><a href="https://tortoisegit.org/" target="_blank" rel="noreferrer">TortoiseGit</a> 在 Windows 外壳程序中，TortoiseGit 提供了显示文件状态的覆盖图标，一个强大的 Git 上下文菜单等等！</p><ul><li>下载：<a href="https://tortoisegit.org/download/" target="_blank" rel="noreferrer">https://tortoisegit.org/download/</a></li></ul></blockquote><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><p><a href="https://git-scm.com/docs/git" target="_blank" rel="noreferrer">Git 命令一览</a></p></li><li><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noreferrer">Git 官方操作手册</a></p></li><li><p><a href="https://www.answerywj.com/2020/09/29/git-help-v3/" target="_blank" rel="noreferrer">Git 速查手册（第三版）</a></p></li></ul>',37),c=[d];function h(p,g,u,m,b,_){return e(),r("div",null,c)}const q=t(n,[["render",h]]);export{x as __pageData,q as default};
